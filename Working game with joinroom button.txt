Working game with joinroom button:
server.js 



const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});
const BOARD_SIZE = 8;
let turnCounter = 0;
// Store the game state and rooms
const games = {};

// Helper function to randomly place terrain on a row
function placeRandomTerrain(board, row, type, count) {
    const availableCols = [...Array(BOARD_SIZE).keys()]; // Columns 0 to 7
    for (let i = 0; i < count; i++) {
        const randomIndex = Math.floor(Math.random() * availableCols.length);
        const col = availableCols.splice(randomIndex, 1)[0]; // Remove the chosen column from the pool
        board[row][col].terrain = type; // Assign the terrain type (water/red)
    }
}

function createGameBoard() {
    const board = Array(BOARD_SIZE).fill(null).map(() =>
        Array(BOARD_SIZE).fill(null).map(() => ({ terrain: 'normal', unit: '' })) // Separate terrain and unit
    );

   // Place Player 1's Warrior (W) units (6 pawns instead of 8)
    for (let i = 1; i <= 6; i++) {  // Place pawns from column 1 to 6
    board[1][i].unit = 'P1_W';  // Player 1 Warriors
    }

// Place Player 2's Warrior (W) units (6 pawns instead of 8)
    for (let i = 1; i <= 6; i++) {  // Place pawns from column 1 to 6
    board[6][i].unit = 'P2_W';  // Player 2 Warriors
    }


    // Add Player 1 and Player 2's Horse (H) units
    board[0][2].unit = 'P1_H';
    board[0][5].unit = 'P1_H';
    board[7][2].unit = 'P2_H';
    board[7][5].unit = 'P2_H';

    // Add Player 1 and Player 2's Archer (A) units
    board[0][4].unit = 'P1_M';
    board[7][3].unit = 'P2_M';
    board[0][0].unit = 'P1_A';
    board[7][0].unit = 'P2_A';
    board[0][7].unit = 'P1_A';
    board[7][7].unit = 'P2_A';
    // Add Towers for Player 1 and Player 2
    board[3][0] = { terrain: 'normal', unit: 'P1_T', hp: 26 };  // Player 1 Tower
    board[4][7] = { terrain: 'normal', unit: 'P2_T', hp: 28 };  // Player 2 Tower

    // Randomly place water and red terrain on rows 2-5
    for (let row = 2; row <= 5; row++) {
        const waterCount = Math.floor(Math.random() * 3) + 1;  // Random 1-3 water tiles
        const redCount = Math.floor(Math.random() * 2);  // Random 0-4 red tiles

        placeRandomTerrain(board, row, 'water', waterCount);
        placeRandomTerrain(board, row, 'red', redCount);
    }

    return board;
}

// Serve static files from the "public" directory
app.use(express.static('public'));

io.on('connection', (socket) => {
    console.log('A player connected:', socket.id);

    socket.on('joinRoom', (data) => {
        const { roomId, general } = data;
        console.log(`Player ${socket.id} joined room ${roomId} with General ${general}`);
        
        if (!games[roomId]) {
            games[roomId] = {
                players: [],
                board: createGameBoard(),
                turn: 'P1',
                actionCount: 0,  // Track actions for the current player
                generals: {},
                unitHasAttacked: {},  // Track attacks per unit
                unitHasMoved: {}  // Track moves per unit
            };
              // Reset the turnCounter when a new game starts (first player joins)
              turnCounter = 0;

              // Emit the reset turn counter to both players
              io.to(roomId).emit('updateTurnCounter', turnCounter);
        }

        const game = games[roomId];

        if (game.players.length >= 2) {
            socket.emit('roomFull');
            return;
        }

        game.players.push(socket.id);

        const playerNumber = game.players.length === 1 ? 'P1' : 'P2';
        game.generals[playerNumber] = general;

        if (playerNumber === 'P1') {
            game.board[0][3].unit = `P1_${general}`;  // Player 1 General
        } else {
            game.board[7][4].unit = `P2_${general}`;  // Player 2 General
        }

        socket.emit('playerNumber', { playerNumber, board: game.board, turn: game.turn, general });

        socket.join(roomId);

        if (game.players.length === 2) {
            io.to(roomId).emit('gameStart', game.board);
        }

        function checkWinCondition(game, player) {
            const opponent = player === 'P1' ? 'P2' : 'P1';
            
            // Check if opponent's tower is destroyed
            const opponentTower = opponent === 'P1' ? 'P1_T' : 'P2_T';
            let towerAlive = false;
            let unitsAlive = false;
        
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const unit = game.board[row][col].unit;
                    if (unit === opponentTower) {
                        towerAlive = true;
                    }
                    // Check if any of the opponent's units (except towers) are still alive
                    if (unit && unit.startsWith(opponent) && unit !== opponentTower) {
                        unitsAlive = true;
                    }
                }
            }
        
            // Winning condition: if opponent's tower is destroyed OR if no opponent units (except towers) are alive
            if (!towerAlive || !unitsAlive) {
                return true;  // Winning condition met
            }
        
            return false;
        }

        socket.on('saveGameState', (gameState) => {
            const game = games[gameState.roomId];
            game.board = gameState.board;
            game.turn = gameState.turn;
            game.actionCount = gameState.actionCount;
            game.unitHasAttacked = gameState.unitHasAttacked;
            game.playerNumber = gameState.playerNumber;
        });

        socket.on('getGameState', (roomId) => {
            const game = games[roomId];
            if (game) {
                // Send the current game state back to the client
                socket.emit('gameState', {
                    board: game.board,
                    turn: game.turn,
                    playerNumber: game.players.includes(socket.id) ? 'P1' : 'P2', // Assign the player number
                    actionCount: game.actionCount,
                    unitHasAttacked: game.unitHasAttacked
                });
            }
        });
        socket.on('makeMove', (moveData) => {
            const game = games[moveData.roomId];
        
            if (game.turn !== moveData.player) {
                socket.emit('notYourTurn');
                return;
            }
        
            const { from, to } = moveData.move;
            const attackingPiece = game.board[from.row][from.col].unit;
            const targetPiece = game.board[to.row][to.col].unit;
            const fromTerrain = game.board[from.row][from.col].terrain;
            const destination = game.board[to.row][to.col].terrain;
        
            // Prevent movement onto water terrain
            if (destination === 'water' && !targetPiece.startsWith('P1_T') && !targetPiece.startsWith('P2_T')) {
                socket.emit('invalidAction', 'You cannot move onto water terrain.');
                return;
            }
        
            const attackingUnit = `${from.row},${from.col}`;
        
            // Check if the unit already attacked this turn but allow movement after attack
            if (game.unitHasAttacked[attackingUnit] && targetPiece) {
                socket.emit('invalidAction', 'This unit has already attacked this turn.');
                return;
            }
        
            // Check if the unit has already moved twice
            if (game.unitHasMoved[attackingUnit] >= 2 && !targetPiece) {
                socket.emit('invalidAction', 'This unit has already moved twice this turn.');
                return;
            }
        
            // Prevent players from attacking their own towers
            if ((targetPiece === 'P1_T' && game.turn === 'P1') || (targetPiece === 'P2_T' && game.turn === 'P2')) {
                socket.emit('invalidAction', 'You cannot attack your own tower!');
                return;
            }
        
            // Helper function to calculate damage based on unit type
            function getUnitDamage(unit) {
                if (unit.startsWith('P1_W') || unit.startsWith('P2_W')) {
                    return 2;  // Warrior deals 2 damage
                } else if (unit.startsWith('P1_H') || unit.startsWith('P2_H')) {
                    return 2;  // Horse deals 2 damage
                } else if (unit.startsWith('P1_M') || unit.startsWith('P2_M')) {
                    return 3;  // Mage deals 3 damage
                } else if (unit.startsWith('P1_A') || unit.startsWith('P2_A')) {
                    return 1;  // Archer deals 1 damage
                } else if (unit.startsWith('P1_GW') || unit.startsWith('P2_GW')) {
                    return 3;  // General Warrior deals 3 damage
                } else if (unit.startsWith('P1_GH') || unit.startsWith('P2_GH')) {
                    return 3;  // General Warrior deals 3 damage
                } else if (unit.startsWith('P1_GA') || unit.startsWith('P2_GA')) {
                    return 2;  // General Warrior deals 3 damage
                }
                return 0;  // Default no damage for unrecognized units
            }
        
            // Handle attacks
            if (targetPiece) {
                console.log(`Player ${moveData.player} attacking ${targetPiece} at (${to.row}, ${to.col})`);
        
                let isTower = false;
                let hitChance = 1.0;
                let damage = getUnitDamage(attackingPiece);  // Get damage based on unit type
        
                // Check if the target is a tower
                if (targetPiece === 'P1_T' || targetPiece === 'P2_T') {
                    isTower = true;
                }
        
                // Deal damage to towers
                if (isTower) {
                    const tower = game.board[to.row][to.col];
        
                    if (!tower.hp) {
                        tower.hp = 28;  // Initialize tower HP if not already set
                    }
        
                    tower.hp -= damage;  // Apply damage to tower
        
                    console.log(`Tower at (${to.row}, ${to.col}) now has ${tower.hp} HP after taking ${damage} damage.`);
        
                    if (tower.hp <= 0) {
                        console.log(`Tower ${targetPiece} is destroyed!`);
                        game.board[to.row][to.col].unit = '';  // Remove the tower from the board
                        io.to(moveData.roomId).emit('towerDestroyed', `Tower ${targetPiece} is destroyed!`);
        
                        if (checkWinCondition(game, game.turn)) {
                            io.to(moveData.roomId).emit('gameOver', {
                                message: `Player ${moveData.player} wins!`,
                                winner: moveData.player,
                                loser: game.turn === 'P1' ? 'P2' : 'P1'  // Identify the losing player
                            });
                            return;
                        }
                    } else {
                        io.to(moveData.roomId).emit('towerDamaged', `Tower ${targetPiece} is damaged! Remaining HP: ${tower.hp}`);
                    }
                } else {
                     // Special avoidance for General Horse when attacked by an Archer
                   

                   // Mage always hits (no avoidance)
                   if (attackingPiece.startsWith('P1_M') || attackingPiece.startsWith('P2_M')) {
                    hitChance = 1.0;  // Mages always hit (no avoidance)
                } else if (attackingPiece.startsWith('P1_A') || attackingPiece.startsWith('P2_A')) {
                    // Specific avoidance logic for Archers attacking General Horse (GH)
                    if (targetPiece.startsWith('P1_GH') || targetPiece.startsWith('P2_GH')) {
                        hitChance = 0.00;  // General Horse avoids Archer attacks 100% of the time
                    } else {
                        // Regular avoidance logic for Archers hitting other units
                        if (targetPiece.startsWith('P1_H') || targetPiece.startsWith('P2_H')) {
                            hitChance = 0.5;  // Horse has a 50% chance to avoid
                        } else if (targetPiece.startsWith('P1_W') || targetPiece.startsWith('P2_W')) {
                            hitChance = 0.4;  // Warrior has a 60% chance to avoid
                        } else if (targetPiece.startsWith('P1_A') || targetPiece.startsWith('P2_A')) {
                            hitChance = 0.75;  // Archers have a 25% chance to avoid
                        } else if (targetPiece.startsWith('P1_GW') || targetPiece.startsWith('P2_GW')) {
                            hitChance = 0.2;  // General Warrior has a 20% chance to avoid
                        } else if (targetPiece.startsWith('P1_GA') || targetPiece.startsWith('P2_GA')) {
                            hitChance = 0.5;  // General Archer has a 50% chance to avoid
                        }
                    }
                } else {
                    // Avoidance logic for regular units
                    if (targetPiece.startsWith('P1_H') || targetPiece.startsWith('P2_H')) {
                        hitChance = 0.5;  // Horse has a 50% chance to avoid
                    } else if (targetPiece.startsWith('P1_W') || targetPiece.startsWith('P2_W')) {
                        hitChance = 0.4;  // Warrior has a 60% chance to avoid
                    } else if (targetPiece.startsWith('P1_A') || targetPiece.startsWith('P2_A')) {
                        hitChance = 0.75;  // Archers have a 25% chance to avoid
                    } else if (targetPiece.startsWith('P1_GW') || targetPiece.startsWith('P2_GW')) {
                        hitChance = 0.2;  // General Warrior has a 20% chance to avoid
                    } else if (targetPiece.startsWith('P1_GH') || targetPiece.startsWith('P2_GH')) {
                        hitChance = 0.3;  // General Horse has a 70% chance to avoid against normal units
                    } else if (targetPiece.startsWith('P1_GA') || targetPiece.startsWith('P2_GA')) {
                        hitChance = 0.5;  // General Archer has a 50% chance to avoid
                    }
                
                                
                            
                        // Ignore avoidance if attacking from red terrain
                        if (fromTerrain === 'red' && !isTower) {
                            hitChance = 1.0;
                        }
                        if (attackingPiece === 'P1_T' || attackingPiece === 'P2_T') {
                            const attackingTower = game.board[from.row][from.col];
                
                            if (attackingTower.hp > 0) {
                                attackingTower.hp -= 1;  // Reduce tower HP by 1 on attack
                                console.log(`${attackingPiece} tower now has ${attackingTower.hp} HP after attacking.`);
                
                                // Check if attacking tower is destroyed due to HP loss
                                if (attackingTower.hp <= 0) {
                                    console.log(`Tower ${attackingPiece} is destroyed!`);
                                    game.board[from.row][from.col].unit = '';  // Remove the attacking tower from the board
                                    io.to(moveData.roomId).emit('towerDestroyed', `Tower ${attackingPiece} is destroyed after attacking.`);
                                }
                            }
                        }

                    }
        
                    const hitRoll = Math.random();
                    console.log(hitRoll);
                    if (hitRoll <= hitChance) {
                        console.log(`Attack hit! ${targetPiece} is removed.`);
                        game.board[to.row][to.col].unit = '';  // Remove the target piece
                        io.to(moveData.roomId).emit('attackHit', { message: `Attack hit! ${targetPiece} is removed.`, attackingPiece });
        
                        if (checkWinCondition(game, game.turn)) {
                            io.to(moveData.roomId).emit('gameOver', `Player ${moveData.player} wins!`);
                            return;
                        }
                    } else {
                        console.log(`Attack missed! ${targetPiece} avoided the hit.`);
                        io.to(moveData.roomId).emit('attackMiss', `Attack missed! ${targetPiece} avoided the hit.`);
        
                        // General Warrior counter-attack logic
                        if (targetPiece.startsWith('P1_GW') || targetPiece.startsWith('P2_GW')) {
                            const counterRoll = Math.random();
                            if (counterRoll <= 0.3) {  // 30% chance to counter-attack
                                console.log(`Counter-attack! ${attackingPiece} is removed.`);
                                game.board[from.row][from.col].unit = '';  // Remove the attacking piece
                                io.to(moveData.roomId).emit('counterAttack', `Counter-attack! ${attackingPiece} is removed.`);
        
                                if (checkWinCondition(game, game.turn === 'P1' ? 'P2' : 'P1')) {
                                    io.to(moveData.roomId).emit('gameOver', `Player ${game.turn === 'P1' ? 'P2' : 'P1'} wins!`);
                                    return;
                                }
                            }
                        }
                    }
                }
        
                game.unitHasAttacked[attackingUnit] = true;  // Mark as attacked but allow further movement
            }
        
            // Move logic (if the target piece is empty, i.e., not attacking)
            if (!targetPiece) {
                game.board[to.row][to.col].unit = game.board[from.row][from.col].unit;
                game.board[from.row][from.col].unit = '';
        
                // Track the number of moves for the unit
                if (!game.unitHasMoved[attackingUnit]) {
                    game.unitHasMoved[attackingUnit] = 1;
                } else {
                    game.unitHasMoved[attackingUnit] += 1;
                }
            }
        
            game.actionCount++;
        
            // End the turn after two actions
            if (game.actionCount >= 2) {
                game.turn = game.turn === 'P1' ? 'P2' : 'P1';
                game.actionCount = 0;
                game.unitHasAttacked = {};  // Reset attack tracking
                game.unitHasMoved = {};  // Reset movement tracking
            }
               // Increment the turn counter (full turn is 2 actions per player)
               turnCounter++;
               io.to(moveData.roomId).emit('updateTurnCounter', turnCounter);
               // Every 20 turns, make both towers lose 1 HP
               if (turnCounter >= 100 && turnCounter % 2 === 0) {  // Every 2 full turns after the 20th turn
                   const p1Tower = game.board[3][0];
                   const p2Tower = game.board[4][7];
   
                   // Reduce HP for Player 1's tower
                   if (p1Tower.unit === 'P1_T' && p1Tower.hp > 0) {
                       p1Tower.hp -= 1;
                       console.log(`Player 1's tower loses 1 HP, now at ${p1Tower.hp}`);
                       io.to(moveData.roomId).emit('towerDamaged', `Player 1's tower loses 1 HP! Remaining HP: ${p1Tower.hp}`);
   
                       // Check if Player 1's tower is destroyed
                       if (p1Tower.hp <= 0) {
                           game.board[3][0].unit = '';  // Remove the tower from the board
                           io.to(moveData.roomId).emit('towerDestroyed', `Player 1's tower is destroyed!`);
                           if (checkWinCondition(game, 'P2')) {
                            io.to(roomId).emit('gameOver', 'Player 2 wins!');
                            return;
                        }
                       }
                   }
   
                   // Reduce HP for Player 2's tower
                   if (p2Tower.unit === 'P2_T' && p2Tower.hp > 0) {
                       p2Tower.hp -= 1;
                       console.log(`Player 2's tower loses 1 HP, now at ${p2Tower.hp}`);
                       io.to(moveData.roomId).emit('towerDamaged', `Player 2's tower loses 1 HP! Remaining HP: ${p2Tower.hp}`);
   
                       // Check if Player 2's tower is destroyed
                       if (p2Tower.hp <= 0) {
                           game.board[4][7].unit = '';  // Remove the tower from the board
                           io.to(moveData.roomId).emit('towerDestroyed', `Player 2's tower is destroyed!`);
                            // Check for game over, as Player 1 would win
                            if (checkWinCondition(game, 'P1')) {
                             io.to(roomId).emit('gameOver', 'Player 1 wins!');
                                return;
                             }
                           
                       }
                   }
   
                   // Optionally, check for win conditions after a tower is destroyed
                   if (checkWinCondition(game, game.turn)) {
                       io.to(moveData.roomId).emit('gameOver', `Player ${moveData.player} wins!`);
                       return;
                   }
               }
            io.to(moveData.roomId).emit('updateBoard', {
                board: game.board,
                terrain: game.terrain,
                turn: game.turn,
            });
        });
        

        
        socket.on('disconnect', () => {
            console.log(`Player ${socket.id} disconnected`);
            game.players = game.players.filter(player => player !== socket.id);

            if (game.players.length === 0) {
                delete games[roomId];
            }
        });
    });
});

const port = process.env.PORT || 3000;
server.listen(port, () => {
    console.log(`Server running on port ${port}`);
});

























client (script.js):
const socket = io();
let playerNumber;
let turn;
let board = [];
let roomId = null;
let selectedPiece = null;
let actionCount = 0; // Track 2 actions per turn
let previousAttacker = null;  // Track previous attacker to prevent two attacks from the same unit
let unitHasAttacked = {};  // Track which units have attacked in this turn
const backgroundSound = document.getElementById('backgroundSound');
const missSound = document.getElementById('missSound');
const stepSound = document.getElementById('stepSound');
const dieSound = document.getElementById('dieSound');
const horseMoveSound = document.getElementById('horseMoveSound');
const counterSound = document.getElementById('counterAttack');
const youWin = document.getElementById('youWin');
const mageMove = document.getElementById('mageMove');
const spell = document.getElementById('spell');
const towerHit = document.getElementById('towerHit');
const towerExplotion = document.getElementById('towerExplotion');
const loserSound = document.getElementById('loserSound');
// Join a room when the player clicks the join button
function joinRoom() {
    roomId = document.getElementById('roomInput').value.trim();
    const generalChoice = document.getElementById('generalChoice').value; // Get selected general
    if (roomId) {
        backgroundSound.loop = true;
        backgroundSound.volume=0.1;
        backgroundSound.play().then(() => {
            // Audio is now unlocked for future use
            console.log("Audio unlocked for future use");
        }).catch((error) => {
            // Handle errors (if autoplay restrictions are still in place)
            console.log("Audio was not allowed to play:", error);
        });
        if (generalChoice === 'GW' || generalChoice === 'GH' || generalChoice === 'GA') {
            // Emit the joinRoom event with the selected general
            socket.emit('joinRoom', { roomId, general: generalChoice });
        } else {
            alert("Invalid choice, please select a general.");
        }
    }
}
// Function to save the game state to localStorage
function saveGameState() {
    const gameState = {
        board: board,
        turn: turn,
        playerNumber: playerNumber,
        actionCount: actionCount,
        unitHasAttacked: unitHasAttacked,
    };
    localStorage.setItem('gameState', JSON.stringify(gameState));
}

// Save game state before the page unloads or on manual save
window.addEventListener('beforeunload', saveGameState);

// Receive player number and initial board state after joining
socket.on('playerNumber', (data) => {
    playerNumber = data.playerNumber;
    board = data.board;
    turn = data.turn;
    actionCount = 0;

    if (data.general) {
        // Place the General Warrior on the board
        if (playerNumber === 'P1') {
            board[0][3].unit = `P1_${data.general}`;  // Player 1's General Warrior
        } else {
            board[7][4].unit = `P2_${data.general}`;  // Player 2's General Warrior
        }
    }

    renderBoard();
    alert(`You are Player ${playerNumber}`);
});

// When both players have joined, the game starts and the board is set
socket.on('gameStart', (boardData) => {
    board = boardData;
    renderBoard();
    alert('Game started!');
});

// Update the board state after a move
socket.on('updateBoard', (data) => {
    board = data.board;
    turn = data.turn;
    actionCount = 0;  // Reset action count after turn switch
    unitHasAttacked = {};  // Reset attack tracking after turn switch
    renderBoard();
    document.getElementById('turnInfo').textContent = `It's ${turn === 'P1' ? 'Player 1' : 'Player 2'}'s turn`;
});

// Listen for the turn counter update from the server
socket.on('updateTurnCounter', (turnCounter) => {
    document.getElementById('turnCounterDisplay').textContent = `Turn: ${turnCounter}`;
});
// Listen for the turn counter update from the server
socket.on('updateTurnCounter', (turnCounter) => {
    document.getElementById('turnCounterDisplay').textContent = `Turn: ${turnCounter}`;
});


// Handle attack result
socket.on('attackHit', (data) => {
    const { message, attackingPiece } = data;  // Correctly extract data properties

    // Check if the attacking piece is a Mage (P1_M or P2_M)
    if (attackingPiece.startsWith('P1_M') || attackingPiece.startsWith('P2_M')) {
        spell.play();  // Play mage attack sound if Mage is attacking
    } else {
        dieSound.play();  // Play default attack sound
    }
    
    //alert(message);
});

// Handle tower damaged event
socket.on('towerDamaged', (message) => {
    //alert(message);  // You can display this message or update a UI element to show the tower's health.
    towerHit.play();

});

// Handle tower destroyed event
socket.on('towerDestroyed', (message) => {
    alert(message);  // You can display a message or remove the tower visually from the board.
    towerExplotion.play();
});

// Handle counter-attack result
socket.on('counterAttack', (message) => {
    counterSound.play();
    alert(message);
});

// Handle missed attacks
socket.on('attackMiss', (message) => {
    //alert(message);
    playOnMiss();
});

// Notify if it's not the player's turn
socket.on('notYourTurn', () => {
    alert('It is not your turn!');
});

// Handle game over event
socket.on('gameOver', (data) => {
    const { message, winner, loser } = data;

    if (playerNumber === winner) {
        youWin.play();  // Play winning sound
        alert('Congratulations! You won!');
    } else if (playerNumber === loser) {
        loserSound.play();  // Play losing sound
        alert('You lost! Better luck next time!');
    }

    // Delay the reload to allow the sounds to play
    setTimeout(() => {
        location.reload();
    }, 6000);  // Delay the reload by 3 seconds
});

let unitHasMoved = {};  // Track which units have moved this turn

function onClick(row, col) {
    console.log(`Clicked cell: (${row}, ${col})`);

    // Deselect previous selected piece (if any)
    if (selectedPiece) {
        const previousSelectedCell = document.querySelector('.selected-cell');
        if (previousSelectedCell) {
            previousSelectedCell.classList.remove('selected-cell');
        }
    }

    if (turn !== playerNumber) {
        alert('Not your turn!');
        return;
    }

    const piece = board[row][col].unit;
    console.log(`Clicked piece: ${piece}`);

    const attackingUnit = `${selectedPiece?.row},${selectedPiece?.col}`;  // Unique ID for the attacking unit

    if (!selectedPiece && piece.startsWith(playerNumber)) {
        selectedPiece = { row, col };
        console.log(`Selected piece: ${piece} at (${row}, ${col})`);

        // Add selected-cell class to the selected square
        const selectedCell = document.querySelector(`tr:nth-child(${row + 1}) td:nth-child(${col + 1})`);
        selectedCell.classList.add('selected-cell');

    } else if (selectedPiece) {
        const from = selectedPiece;
        const to = { row, col };
        console.log(`Attempting move from (${from.row}, ${from.col}) to (${to.row}, ${to.col})`);

        if (actionCount < 2) {
            // Check if the unit has already attacked
            if (unitHasAttacked[attackingUnit] && board[to.row][to.col].unit.startsWith(playerNumber === 'P1' ? 'P2' : 'P1')) {
                alert('This unit has already attacked this turn!');
                return;
            }

            if (!board[to.row][to.col].unit) {
                // Move piece logic
                if (isValidMove(board[from.row][from.col], from.row, from.col, to.row, to.col)) {
                    makeMove(from, to);
                    actionCount++;
                    unitHasMoved[attackingUnit] = true;

                    // Deselect the cell after move
                    const selectedCell = document.querySelector(`tr:nth-child(${from.row + 1}) td:nth-child(${from.col + 1})`);
                    selectedCell.classList.remove('selected-cell');
                } else {
                    console.log(`Invalid move from (${from.row}, ${from.col}) to (${to.row}, ${to.col})`);
                }
            } else if (board[to.row][to.col].unit.startsWith(playerNumber === 'P1' ? 'P2' : 'P1')) {
                // Attack logic, including Towers
                if (isValidAttack(board[from.row][from.col], from.row, from.col, to.row, to.col)) {
                    console.log(`Attacking opponent's piece: ${board[to.row][to.col].unit}`);
                    makeMove(from, to);  // Handle attacks with the same makeMove method
                    actionCount++;

                    // Mark this unit as having attacked
                    unitHasAttacked[attackingUnit] = true;

                    // Deselect the cell after attack
                    const selectedCell = document.querySelector(`tr:nth-child(${from.row + 1}) td:nth-child(${from.col + 1})`);
                    selectedCell.classList.remove('selected-cell');
                } else {
                    console.log(`Invalid attack from (${from.row}, ${from.col}) to (${to.row}, ${to.col})`);
                }
            }

            // Allow unit to move after attacking
            if (unitHasAttacked[attackingUnit] && !unitHasMoved[attackingUnit] && actionCount < 2) {
                console.log(`Unit can still move after attacking`);
                selectedPiece = from;  // Set the unit as still selected for a move
            }

            if (actionCount === 2) {
                endTurn();
            }
        } else {
            alert('You have already performed 2 actions this turn.');
        }

        selectedPiece = null;  // Deselect after action
    }
}

// Validate if the move is correct for Warrior (W), Horse (H), Archer (A), General Warrior (GW), or Towers
function isValidMove(pieceData, fromRow, fromCol, toRow, toCol) {
    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);
    const destination = board[toRow][toCol].terrain;  // Access the destination terrain

    // Prevent units from stepping on water
    if (destination === 'water') {
        console.log('Cannot move onto water terrain!');
        return false;
    }

    const piece = pieceData.unit;

    // Warrior (W), General Warrior (GW), and Towers can't move
    if (piece.startsWith('P1_T') || piece.startsWith('P2_T')) {
        return false; // Towers can't move
    }

    if (piece.startsWith('P1_W') || piece.startsWith('P2_W') || 
        piece.startsWith('P1_GW') || piece.startsWith('P2_GW')) {
        return rowDiff <= 1 && colDiff <= 1;
    }

    // Horse (H) can move up to 3 spaces in a straight line (including diagonal)
    if (piece.startsWith('P1_H') || piece.startsWith('P2_H')) {
        return (rowDiff <= 3 && colDiff === 0) ||  // Straight vertical
               (colDiff <= 3 && rowDiff === 0) ||  // Straight horizontal
               (rowDiff === colDiff && rowDiff <= 3);  // Diagonal
    }
    if (piece.startsWith('P1_GH') || piece.startsWith('P2_GH')) {
        return (rowDiff <= 3 && colDiff === 0) ||  // Straight vertical
               (colDiff <= 3 && rowDiff === 0) ||  // Straight horizontal
               (rowDiff === colDiff && rowDiff <= 3);  // Diagonal
    }

    // Archer (A) can move 1 space in any direction
    if (piece.startsWith('P1_A') || piece.startsWith('P2_A')) {
        return rowDiff <= 1 && colDiff <= 1;
    }
     // Archer (A) can move 1 space in any direction
     if (piece.startsWith('P1_GA') || piece.startsWith('P2_GA')) {
        return rowDiff <= 1 && colDiff <= 1;
    }

      //Mage can move 1 space in any direction
      if (piece.startsWith('P1_M') || piece.startsWith('P2_M')) {
        return rowDiff <= 1 && colDiff <= 1;
    }


    return false;
}

// Make a move and notify the server
function makeMove(from, to) {
    socket.emit('makeMove', { roomId, player: playerNumber, move: { from, to } });
    const movingPiece = board[from.row][from.col].unit;

    // Check if the moving piece is a Horse or Mage
    if (movingPiece.startsWith('P1_H') || movingPiece.startsWith('P2_H') || movingPiece.startsWith('P1_GH') || movingPiece.startsWith('P2_GH')) {
        horseMoveSound.play();  // Play horse move sound
    } else if (movingPiece.startsWith('P1_M') || movingPiece.startsWith('P2_M')) {
        mageMove.play();  // Play mage move sound
    } else {
        stepSound.play();  // Play regular move sound for all other units
    }


    selectedPiece = null;  // Deselect after the move
}

// Validate if the attack is valid
function isValidAttack(pieceData, fromRow, fromCol, toRow, toCol) {
    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);

    let ignoreAvoidance = false;

    // Check if the attacker is standing on red terrain
    if (board[fromRow][fromCol].terrain === 'red') {
        ignoreAvoidance = true;
        console.log('Attacking from red terrain: Ignoring avoidance!');
    }

    const piece = pieceData.unit;

    // General Warrior (GW), Warrior (W), and Towers attack logic (adjacent pieces, 1 space away in any direction)
    if (piece.startsWith('P1_W') || piece.startsWith('P2_W') ||
        piece.startsWith('P1_GW') || piece.startsWith('P2_GW') ||
        piece.startsWith('P1_T') || piece.startsWith('P2_T')) {
        return rowDiff <= 1 && colDiff <= 1;
    }

    // Archer (A) attack logic: attack up to 3 spaces away in straight lines (no diagonal attacks)
    if (piece.startsWith('P1_A') || piece.startsWith('P2_A')) {
        return (rowDiff === 0 && colDiff <= 3) ||  // Horizontal attack
               (colDiff === 0 && rowDiff <= 3);  // Vertical attack
    }
     //GENERAL Archer (GA) attack logic: attack up to 3 spaces away in straight lines (no diagonal attacks)
     if (piece.startsWith('P1_GA') || piece.startsWith('P2_GA')) {
        return (rowDiff === 0 && colDiff <= 4) ||  // Horizontal attack
               (colDiff === 0 && rowDiff <= 4);  // Vertical attack
    }
     // Archer (A) attack logic: attack up to 3 spaces away in straight lines (no diagonal attacks)
     if (piece.startsWith('P1_M') || piece.startsWith('P2_M')) {
        return (rowDiff === 0 && colDiff <= 2) ||  // Horizontal attack
               (colDiff === 0 && rowDiff <= 2);  // Vertical attack
    }
    // Horse (H) attack logic (adjacent pieces, 1 space away in any direction)
    if (piece.startsWith('P1_H') || piece.startsWith('P2_H')) {
        return rowDiff <= 1 && colDiff <= 1;
    }
    // Horse (H) attack logic (adjacent pieces, 1 space away in any direction)
    if (piece.startsWith('P1_GH') || piece.startsWith('P2_GH')) {
        return rowDiff <= 1 && colDiff <= 1;
    }

    return false;
}

// End the turn
function endTurn() {
    actionCount = 0;  // Reset the action count for the next turn
    unitHasAttacked = {};  // Reset the attack tracker for the new turn
    previousAttacker = null;  // Reset the previous attacker
    selectedPiece = null;  // Deselect the current piece
    unitHasAttacked = {};
    socket.emit('endTurn', { roomId, player: playerNumber });
}

// Render the board in the HTML
function renderBoard() {
    const gameBoard = document.getElementById('gameBoard');
    gameBoard.innerHTML = '';

    for (let row = 0; row < board.length; row++) {
        const tr = document.createElement('tr');
        for (let col = 0; col < board[row].length; col++) {
            const td = document.createElement('td');
            td.classList.add('board-cell');

            const terrainType = board[row][col].terrain;  // Get terrain type
            const unitType = board[row][col].unit;  // Get unit type

            // Set terrain background based on terrain type
            if (terrainType === 'water') {
                td.classList.add('water-terrain');
            } else if (terrainType === 'red') {
                td.classList.add('red-terrain');
            } else {
                td.classList.add('normal-terrain');
            }

            // Display unit image based on unit type, including tower health
            if (unitType) {
                const unitImage = document.createElement('img');
                unitImage.src = getImageForUnit(unitType);  // Set the image source based on the unit
                unitImage.classList.add('unit-image');  // Optional: Add a class for styling
                td.appendChild(unitImage);

                // Display tower HP if it's a tower
                if (unitType === 'P1_T' || unitType === 'P2_T') {
                    const tower = board[row][col];
                    if (tower.hp) {
                        const hpDisplay = document.createElement('div');
                        hpDisplay.textContent = `${tower.hp}`;
                        hpDisplay.classList.add('tower-hp');  // Add this class
                        td.appendChild(hpDisplay);
                    }
                }
            }

            td.onclick = () => onClick(row, col);  // Add click handler
            tr.appendChild(td);
        }
        gameBoard.appendChild(tr);
    }
}

// Helper function to return the image path for a given unit type
function getImageForUnit(unitType) {
    const unitImages = {
        'P1_W': '/resources/images/p1.pawn.png',
        'P2_W': '/resources/images/p2_pawn.png',
        'P1_H': '/resources/images/p1_horse.png',
        'P2_H': '/resources/images/p2_horse.jpg',
        'P1_A': '/resources/images/p1_archer.png',
        'P2_A': '/resources/images/p2_a.png',
        'P1_GW': '/resources/images/p1_gp.png',  // Example: General Warrior image for Player 1
        'P2_GW': '/resources/images/p2_gp.png',  // Example: General Warrior image for Player 2
        'P1_T': '/resources/images/p1_t.png',        // Example: Tower 1 image
        'P2_T': '/resources/images/p2_t.png',         // Example: Tower 2 image
        'P1_GA': '/resources/images/p1_ga.png',
        'P2_GA': '/resources/images/p2_ga.png',
        'P1_GH': '/resources/images/p1_gh.png',
        'P2_GH': '/resources/images/p2_gh.png',
        'P1_M': '/resources/images/p1_mage.png',
        'P2_M': '/resources/images/p2_mage.png'
        // Add other units as needed
    };
    return unitImages[unitType] || '';  // Return the image URL or an empty string if no unit
}

// Example: Play sound when a move or attack occurs
function playOnMiss(){
    missSound.play()
}


// Attach the joinRoom function to the join button
document.getElementById('joinButton').onclick = joinRoom;